{"version":3,"sources":["reportWebVitals.js","components (pure functions)/Card.js","components (pure functions)/CardList.js","components (pure functions)/SearchBox.js","components (pure functions)/ErrorBoundary.js","components (pure functions)/Scroll.js","containers/App.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Card","name","id","email","className","alt","src","CardList","robots","map","user","i","SearchBox","searchChange","type","placeholder","onChange","ErrorBoundary","props","state","hasErrors","error","errorInfo","this","setState","children","Component","Scroll","style","overflowY","border","height","App","onSearchChange","event","searchField","target","value","fetch","response","json","users","filteredRobots","filter","robot","toLowerCase","includes","length","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gMAYeA,G,MAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,Q,2CCkBCQ,EApBF,SAAC,GAAuB,IAAtBC,EAAqB,EAArBA,KAAMC,EAAe,EAAfA,GAAIC,EAAW,EAAXA,MACrB,OAGI,aAFA,CAEA,qBACI,sBAAKC,UAAW,sDAAhB,UAEI,qBAAKC,IAAI,SACJC,IAAG,+BAA0BJ,EAA1B,cACR,gCAEI,6BAAKD,IAEL,4BAAIE,aCQTI,EAvBE,SAAC,GAAc,IAAbC,EAAY,EAAZA,OAIf,OACI,8BAGQA,EAAOC,KAAI,SAACC,EAAMC,GAGlB,OAAS,cAAC,EAAD,CAETT,GAAIM,EAAOG,GAAGT,GACdD,KAAMO,EAAOG,GAAGV,KAChBE,MAAOK,EAAOG,GAAGR,OAHZQ,SCANC,EAbG,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aAChB,OACI,qBAAKT,UAAW,MAAhB,SACA,uBACIA,UAAW,sCACXU,KAAK,SACLC,YAAY,gBACZC,SAAUH,OCaPI,G,wDAnBX,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,CACTC,WAAW,GAHA,E,qDAOnB,SAAkBC,EAAOC,GACrBC,KAAKC,SAAS,CAAEJ,WAAW,M,oBAG/B,WACI,OAAIG,KAAKJ,MAAMC,UACJ,wDAEJG,KAAKL,MAAMO,a,GAhBEC,cCqBbC,EATA,SAACT,GACZ,OACI,qBAAKU,MAAO,CAAgCC,UAAW,SAAUC,OAAQ,kBAAmBC,OAAO,SAAnG,SACKb,EAAMO,YC2CJO,E,kDAnDX,aAAe,IAAD,8BACV,gBAkBJC,eAAiB,SAACC,GAEd,EAAKV,SAAS,CAACW,YAAaD,EAAME,OAAOC,SAnBzC,EAAKlB,MAAQ,CACTX,OAAQ,GACR2B,YAAa,IAJP,E,qDAYd,WAAqB,IAAD,OAChBG,MAAM,8CACD5C,MAAK,SAAA6C,GAAQ,OAAIA,EAASC,UAC1B9C,MAAK,SAAA+C,GAAK,OAAI,EAAKjB,SAAS,CAAChB,OAAQiC,S,oBAW9C,WAAU,IAAD,EACyBlB,KAAKJ,MAA5BX,EADF,EACEA,OAAQ2B,EADV,EACUA,YACTO,EAAiBlC,EAAOmC,QAAO,SAAAC,GAEjC,OAAOA,EAAM3C,KAAK4C,cAAcC,SAASX,EAAYU,kBAEzD,OAAQrC,EAAOuC,OAIP,8BACI,sBAAK3C,UAAW,KAAhB,UACI,oBAAIA,UAAU,KAAd,yBACA,cAAC,EAAD,CAAWS,aAAcU,KAAKU,iBAC9B,cAAC,EAAD,UACI,cAAC,EAAD,UACI,cAAC,EAAD,CAAUzB,OAAQkC,aARtC,6C,GAnCMhB,aCAlBsB,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,EAAD,MAEJC,SAASC,eAAe,SAM5B7D,M","file":"static/js/main.a44ff1f1.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React, {Fragment} from 'react';\r\n\r\n// const Card = (props) => {\r\n//Shortens the need to write props.name, props.email, and props.id every time, or:\r\n// const {name, email, id} = props;\r\nconst Card = ({name, id, email}) => {\r\n    return (\r\n        //Tachyons are used here as false css classes\r\n        //A fragment allows us to not do full arrays like return [] but use multiple entries rather than one\r\n        <>\r\n            <div className={'tc bg-light-green dib br3 pa3 ma2 grow bw2 shadow-5'}>\r\n                {/*Robo hash props.id allows to randomize the props parameter based on id from robots.js*/}\r\n                <img alt='robots'\r\n                     src={`https://robohash.org/${id}?200x200`}/>\r\n                <div>\r\n                    {/*Using the name from the array ID (refer to robots.js) using props param*/}\r\n                    <h2>{name}</h2>\r\n                    {/*Using the email from the robots.js array IDs using props param in the function*/}\r\n                    <p>{email}</p>\r\n                </div>\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Card;\r\n","import React from 'react';\r\nimport Card from './Card.js';\r\n\r\nconst CardList = ({robots}) => {\r\n    // if (true) {\r\n    //     throw new Error('NOOOOOOO!')\r\n    // }\r\n    return (\r\n        <div>\r\n            {\r\n                /*Using array from robots.js to signify the IDs used, as well as name and emails*/\r\n                robots.map((user, i) => {\r\n                //Needs a key prop to keep track of all IDs when one is deleted otherwise React won't know which one's which,\r\n                // can call it something related to the index\r\n                return ( <Card\r\n                key={i}\r\n                id={robots[i].id}\r\n                name={robots[i].name}\r\n                email={robots[i].email}/>\r\n                );\r\n            })\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default CardList;\r\n","import React from 'react';\r\n\r\nconst SearchBox = ({searchChange}) => {\r\n    return (\r\n        <div className={'pa2'}>\r\n        <input\r\n            className={'pa3 ba b--green bg bg-lightest-blue'}\r\n            type='search'\r\n            placeholder='search robots'\r\n            onChange={searchChange}\r\n        />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SearchBox;\r\n","import React, { Component } from 'react';\r\n\r\nclass ErrorBoundary extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            hasErrors: false\r\n        }\r\n    }\r\n\r\n    componentDidCatch(error, errorInfo) {\r\n        this.setState({ hasErrors: true})\r\n    }\r\n\r\n    render() {\r\n        if (this.state.hasErrors) {\r\n            return <h1>Oops! That is not good</h1>\r\n        }\r\n        return this.props.children\r\n    }\r\n}\r\n\r\nexport default ErrorBoundary;\r\n","import React from 'react';\r\n// There are props (properties)\r\n// There is state\r\n// There are children\r\n// Scroll can use children as a way to render its children\r\n\r\n\r\n// const Scroll = (props) => {\r\n//     console.log(props)\r\n//     return props.children\r\n// };\r\n// Even though the above item passes any properties to Scroll, every single component in React has \"children\"\r\n// Children has CardList\r\n\r\nconst Scroll = (props) => {\r\n    return(\r\n        <div style={{/*Javascript expression here*/ overflowY: 'scroll', border: '1px solid black', height:'800px'}}>\r\n            {props.children}\r\n        </div>\r\n    );\r\n};\r\n// Now can just add styles with div\r\n\r\nexport default Scroll;\r\n","import React, {Component} from 'react';\r\nimport CardList from '../components (pure functions)/CardList.js';\r\nimport SearchBox from '../components (pure functions)/SearchBox.js';\r\nimport './App.css';\r\nimport ErrorBoundary from '../components (pure functions)/ErrorBoundary.js';\r\nimport Scroll from '../components (pure functions)/Scroll.js';\r\n\r\n// The entire app is described through state (we tell the app what state it has). In this case, the entire app is described through the constructors (states) of robots and searchfield. We tell these two what the state is. What are the functions that should be passed through these states\r\nclass App extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            robots: [],\r\n            searchField: ''\r\n        }\r\n    }\r\n\r\n// These special components (pure functions) are impure since they have states, but they belong to containers, which just passes down states to other components (pure functions)\r\n\r\n\r\n// componentDidMount() is built in so don't need any arrows\r\n    componentDidMount() {\r\n        fetch('https://jsonplaceholder.typicode.com/users')\r\n            .then(response => response.json())\r\n            .then(users => this.setState({robots: users})); /*Updating the state so render runs again*/\r\n    }\r\n\r\n\r\n    onSearchChange = (event) => {\r\n        // To actually set the state so constructor will activate the searchfield properly\r\n        this.setState({searchField: event.target.value})\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n        const {robots, searchField} = this.state;\r\n        const filteredRobots = robots.filter(robot => {\r\n            //If robots name (lower cased) includes the search field then return matching\r\n            return robot.name.toLowerCase().includes(searchField.toLowerCase())\r\n        })\r\n        return !robots.length ? /*robots.length === 0 but shorthand, will equal zero*/\r\n            /*If there are no robots, replace with Loading*/\r\n            <h1>Loading</h1> :\r\n            (\r\n                <div>\r\n                    <div className={'tc'}>\r\n                        <h1 className='f1'>RoboFriends</h1>\r\n                        <SearchBox searchChange={this.onSearchChange}/>\r\n                        <Scroll>\r\n                            <ErrorBoundary>\r\n                                <CardList robots={filteredRobots}/>\r\n                            </ErrorBoundary>\r\n                        </Scroll>\r\n                    </div>\r\n                </div>\r\n            );\r\n        }\r\n}\r\n\r\nexport default App;\r\n\r\n//The above is now constantly changing so now it needs to communicate with 'filteredRobots'\r\n\r\n// How it works:\r\n// 1. App component with two states - 'robots' and 'searchField'. Any component with state uses 'class' syntax\r\n\r\n// 2. Virtual DOM collects entire state which React uses to render and pass them down as props to the components (pure functions)\r\n\r\n// 3. Components are pure functions so they render. App will always look the same\r\n\r\n// 4. App only changes the state\r\n\r\n// 5. Pass down things as props so passed down 'onSearchChange' to the 'SearchBox'\r\n\r\n// 6. Every time there's an 'onChange' on the input, the SearchBox communicates with App.js saying \"there was a change\",\r\n// telling it to run the onSearchChange function\r\n\r\n// 7. Function runs and updates the state of searchField to whatever is typed\r\n\r\n// 8. Info in searchbox can communicate with cardlist and tell it to filter robot state\r\n\r\n// 9. Smart components (pure functions) have state, have class X extends Component\r\n\r\n// 10. Another thing inside components (pure functions): lifecycle methods. Mounting methods are called when an instance of a\r\n// component is being created and inserted into the DOM. These are lifestyle hooks and they will auto trigger when the\r\n// app gets loaded on the website. Ex. When site is run, and app component is refreshed, then it gets mounted into the\r\n// doc with the ID of root\r\n\r\n// When mounting component, we're replacing the div ID with the entire app. It's the start of the app. The mounting lifecycle hooks\r\n// are in order:\r\n// Does it have constructor()? If so run\r\n// Does it have componentWillMount()? If so run\r\n// Does it have render()? If so run\r\n// Does it have componentDidMount()? If so run\r\n\r\n// 11. Updating can be caused by changes to props or state. Happens when a component is being re-rendered aka website\r\n// is refreshed\r\n\r\n// 12. Unmounting when a component is removed/deleted from the page\r\n\r\n// 13. Fetch is a window method that comes with all browsers\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport 'tachyons';\r\nimport App from './containers/App.js';\r\n\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <App />\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n\r\n\r\n\r\n"],"sourceRoot":""}